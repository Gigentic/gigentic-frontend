// File: .cursorrules
You are an expert in Solana full-stack web3 dApp development, focusing on building and deploying smart contracts using Rust and Anchor, and integrating on-chain data with Web3.js in React.

You use Rust with the Solana Anchor framework for chain program development, and TypeScript with Mocha / Chai for testing the programs. You use React, Tailwind and Solana Web3.js on the frontend. You use nx for tooling and build process.

### General Guidelines

- Prioritize secure, maintainable, performant code.
- Optimize the MVP for practical functionality, not just ideal implementation.

### Solana Program Development (Rust + Anchor)

- Prioritize performance, modularity, and clear separation of concerns.
- Utilize Anchor for simplifying account management, error handling, and program interaction.
- Ensure secure smart contracts with input validation and strict access control.

### Frontend Development (React + Web3.js + Tailwind)

- Use Solana Web3.js for optimized chain interactions.
- Implement responsive design and error handling.
- Use Tailwind for styling with a mobile-first approach. Keep React functional and concise in line with best practices.

### Testing & Deployment

- Write comprehensive tests using Mocha/Chai for contracts and frontend.
- Perform local validation testing before devnet deployment.
- Use continuous deployment pipelines to automate testing/rollouts.

### Code Style & Structure

- Functional programming: prefer small, reusable components, avoid classes.
- Use TypeScript for static checking with interfaces. Avoid enums.
- Keep file structure clean: components, helpers, and static content organized logically.

### Performance & Optimization

- Lazy load non-critical elements; optimize images (using WebP).
- Wrap components in Suspense for async loading with fallbacks.

### Documentation

- Document your code structure clearly—README for usage instructions.
- Update documentation as features evolve or change.

### ChatGPT Models

- Please be aware that 'gpt-4o' is a new model of OpenAI. Don't correct me on this.

### Vercel AI SDK

- Please note that the StreamingTextResponse helper was part of the Vercel AI SDK when it was initially introduced in 2023. However, the SDK underwent a significant update with version 3.2 on June 18, 2024, focusing on new features like Agents, expanded provider support, embeddings, and developer experience improvements. As part of this update, there were breaking changes, and the StreamingTextResponse helper is no longer directly referenced in the newer documentation. The latest verion is 3.4 and I am using this version.


// File: .editorconfig
# Editor configuration, see http://editorconfig.org
root = true

[*]
charset = utf-8
indent_style = space
indent_size = 2
insert_final_newline = true
trim_trailing_whitespace = true

[*.md]
max_line_length = off
trim_trailing_whitespace = false


// File: .eslintignore
node_modules


// File: .eslintrc.json
{
  "root": true,
  "ignorePatterns": ["**/*"],
  "plugins": ["@nx"],
  "overrides": [
    {
      "files": ["*.ts", "*.tsx", "*.js", "*.jsx"],
      "rules": {
        "@nx/enforce-module-boundaries": [
          "error",
          {
            "enforceBuildableLibDependency": true,
            "allow": [],
            "depConstraints": [
              {
                "sourceTag": "*",
                "onlyDependOnLibsWithTags": ["*"]
              }
            ]
          }
        ]
      }
    },
    {
      "files": ["*.ts", "*.tsx"],
      "extends": ["plugin:@nx/typescript"],
      "rules": {}
    },
    {
      "files": ["*.js", "*.jsx"],
      "extends": ["plugin:@nx/javascript"],
      "rules": {}
    }
  ]
}


// File: .prettierignore
# Add files here to ignore them from prettier formatting
/dist
/coverage
/.nx/cache
/.nx/workspace-data
.anchor
anchor/target/deploy
anchor/target/debug
anchor/target/release
anchor/target/sbf-solana-solana
anchor/target/.rustc_info.json
!anchor/target/idl/*.json
!anchor/target/types/*.ts
node_modules
dist
tmp
build
test-ledger

// File: .prettierrc
{
  "singleQuote": true,
  "plugins": [
    "prettier-plugin-rust"
  ],
  "overrides": [
    {
      "files": "*.rs",
      "options": {
        "parser": "rust"
      }
    }
  ]
}

// File: LICENSE
MIT License

Copyright (c) 2024 marci

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


// File: README-repo-setup.md
# Gigentic Frontend App

## Repository Overview

This repository contains the Gigentic full-stack web3 dApp built on the Solana blockchain. Gigentic is a decentralized platform that facilitates collaboration between humans and AI agents with trust-minimized payment flows and verifiable ratings.

## Main Components

- Solana Smart Contracts: Written in Rust using the Anchor framework.
- Frontend: Built with Next.js, React, and Tailwind CSS.
- Blockchain Interaction: Utilizes Solana Web3.js for on-chain interactions.
- AI Integration: Incorporates AI features using the Vercel AI SDK.

## Vercel AI SDK Features in Use

The app is currently using Vercel AI SDK version 3.4. Here are the key features being utilized:

- OpenAI Integration: The app uses the OpenAI provider from the Vercel AI SDK to interact with OpenAI's language models.

```ts
import { openai } from '@ai-sdk/openai';
import { streamText, convertToCoreMessages } from 'ai';

// Allow streaming responses up to 30 seconds
export const maxDuration = 30;

export async function POST(req: Request) {
  const { messages } = await req.json();
  const result = await streamText({
    model: openai('gpt-4o-mini'),
    messages: convertToCoreMessages(messages),
  });

  return result.toDataStreamResponse();
}
```

- Streaming Responses: The streamText function is used to enable real-time streaming of AI-generated responses to the client.
- Message Conversion: The convertToCoreMessages helper is used to format messages in the standardized format expected by the AI SDK.
  - AI Model Configuration: The application is configured to use specific OpenAI models, including a custom 'gpt-4o-mini' model.
- API Route Handlers: The code implements Next.js API route handlers to process chat and completion requests on the server-side.
- Streaming Data Protocol: The app uses the Vercel AI SDK's streaming protocol to efficiently transfer AI-generated content from the backend to the frontend.

```ts
  const { messages, input, handleInputChange, handleSubmit, error } = useChat(
      {
        api: '/api/completion',
        streamProtocol: 'text',
        onError: (error) => {
```

<!-- - React Hooks: The application uses Vercel AI SDK's React hooks like useChat and useCompletion for managing AI interactions in the frontend components.

```ts
import { useCompletion } from 'ai/react';
import { useEffect, useRef, useState } from 'react';

export default function LlamaChat() {
    const { completion, input, handleInputChange, handleSubmit, setInput } = useCompletion();
```

- Error Handling: While not explicitly shown in the provided snippets, the AI SDK typically provides built-in error handling capabilities that are likely being utilized in the app. -->

## Conclusion

The Gigentic Frontend app is a sophisticated web3 application that leverages the power of Solana blockchain and integrates AI capabilities using the Vercel AI SDK. It demonstrates the use of modern web technologies and blockchain development practices, showcasing how decentralized applications can incorporate AI features to create innovative user experiences.


// File: README.md
# Gigentic Frontend

Solana Anchor + Next.js Full Stack Setup

This project was generated with the [create-solana-dapp](https://github.com/solana-developers/create-solana-dapp) generator.

Notes:
- make sure to downgrade rust to version rustc 1.79.0 to avoid problems running anchor


`npx create-solana-dapp@latest`

- Project name: gigentic-frontend
- Next.js
- Tailwind
- Counter Anchor template program

Go to the project folder:

`cd gigentic-frontend`

Delete `package-lock.json` file:

`rm package-lock.json`

Delete `node_modules` folder:

`rm -rf node_modules`

Install dependencies in main gigentic-frontend folder:

`yarn`

#### Local validator setup

Clear validator state:
`rm -rf test-ledger`

Start local validator:
`solana-test-validator`

### Chain code setup

Set up libs in main anchor folder as well

`cd anchor`

`yarn`

#### build

`anchor build`
`anchor keys sync`

#### test

`anchor test --skip-local-validator`

### Run frontend

Set up .env file. (See Google folder for sample keys for a reproducible local-dev setup.)

In main gigentic-frontend folder:
`yarn dev`

==============================================================================

# Docs from the solana-starter-dapp

This project was originally generated with the [create-solana-dapp](https://github.com/solana-developers/create-solana-dapp) generator.

## Getting Started

### Prerequisites

- Node v18.18.0 or higher

- Rust v1.77.2 or higher
- Anchor CLI 0.30.1 or higher
- Solana CLI 1.18.17 or higher

### Installation

#### Clone the repo

```shell
git clone <repo-url>
cd <repo-name>
```

#### Install Dependencies

```shell
npm install
```

#### Start the web app

```
npm run dev
```

## Apps

### anchor

This is a Solana program written in Rust using the Anchor framework.

#### Commands

You can use any normal anchor commands. Either move to the `anchor` directory and run the `anchor` command or prefix the command with `npm run`, eg: `npm run anchor`.

#### Sync the program id:

Running this command will create a new keypair in the `anchor/target/deploy` directory and save the address to the Anchor config file and update the `declare_id!` macro in the `./src/lib.rs` file of the program.

You will manually need to update the constant in `anchor/lib/counter-exports.ts` to match the new program id.

```shell
npm run anchor keys sync
```

#### Build the program:

```shell
npm run anchor-build
```

#### Start the test validator with the program deployed:

```shell
npm run anchor-localnet
```

#### Run the tests

```shell
npm run anchor-test
```

#### Deploy to Devnet

```shell
npm run anchor deploy --provider.cluster devnet
```

### web

This is a React app that uses the Anchor generated client to interact with the Solana program.

#### Commands

Start the web app

```shell
npm run dev
```

Build the web app

```shell
npm run build
```


// File: filesScript.js
const fs = require('fs').promises;
const path = require('path');
const ignore = require('ignore');

async function readGitignore() {
  try {
    const content = await fs.readFile('.fileignore', 'utf8');
    return ignore().add(content.split('\n'));
  } catch (error) {
    if (error.code !== 'ENOENT') {
      console.error('Error reading .fileignore:', error);
    }
    return ignore();
  }
}

async function isTextFile(filePath) {
  try {
    const buffer = await fs.readFile(filePath);
    const fileType = await import('file-type');
    const result = await fileType.fileTypeFromBuffer(buffer);
    return !result; // If file-type can't determine the type, it's likely a text file
  } catch (error) {
    console.error(`Error checking file type for ${filePath}:`, error);
    return false;
  }
}

async function listFiles(dir, ig, fileContents) {
  try {
    const entries = await fs.readdir(dir, { withFileTypes: true });
    for (const entry of entries) {
      const relativePath = path.relative(
        process.cwd(),
        path.join(dir, entry.name),
      );
      const fullPath = path.join(dir, entry.name);

      if (ig.ignores(relativePath)) {
        continue;
      }

      if (entry.isDirectory()) {
        console.log(`${relativePath}${path.sep}`);
        await listFiles(fullPath, ig, fileContents);
      } else {
        console.log(relativePath);
        if (await isTextFile(fullPath)) {
          const content = await fs.readFile(fullPath, 'utf8');
          fileContents.push(`// File: ${relativePath}\n${content}\n\n`);
        }
      }
    }
  } catch (error) {
    console.error('Error reading directory:', error);
  }
}

async function main() {
  const ig = await readGitignore();
  const fileContents = [];
  await listFiles(process.cwd(), ig, fileContents);

  const concatenatedContent = fileContents.join('');
  await fs.writeFile('concat-all.txt', concatenatedContent);
  console.log('All text files have been concatenated into concat-all.txt');
}

main().catch(console.error);


// File: jest.config.ts
import { getJestProjectsAsync } from '@nx/jest';

export default async () => ({
  projects: await getJestProjectsAsync(),
});


// File: jest.preset.js
const nxPreset = require('@nx/jest/preset').default;

module.exports = { ...nxPreset };


// File: nx.json
{
  "$schema": "./node_modules/nx/schemas/nx-schema.json",
  "namedInputs": {
    "default": ["{projectRoot}/**/*", "sharedGlobals"],
    "production": [
      "default",
      "!{projectRoot}/.eslintrc.json",
      "!{projectRoot}/eslint.config.js",
      "!{projectRoot}/**/?(*.)+(spec|test).[jt]s?(x)?(.snap)",
      "!{projectRoot}/tsconfig.spec.json",
      "!{projectRoot}/jest.config.[jt]s",
      "!{projectRoot}/src/test-setup.[jt]s",
      "!{projectRoot}/test-setup.[jt]s"
    ],
    "sharedGlobals": []
  },
  "targetDefaults": {
    "@nx/next:build": {
      "cache": true,
      "dependsOn": ["^build"],
      "inputs": ["production", "^production"]
    },
    "@nx/eslint:lint": {
      "cache": true,
      "inputs": [
        "default",
        "{workspaceRoot}/.eslintrc.json",
        "{workspaceRoot}/.eslintignore",
        "{workspaceRoot}/eslint.config.js"
      ]
    },
    "@nx/jest:jest": {
      "cache": true,
      "inputs": ["default", "^production", "{workspaceRoot}/jest.preset.js"],
      "options": {
        "passWithNoTests": true
      },
      "configurations": {
        "ci": {
          "ci": true,
          "codeCoverage": true
        }
      }
    }
  },
  "generators": {
    "@nx/next": {
      "application": {
        "style": "css",
        "linter": "eslint"
      }
    }
  },
  "plugins": [
    {
      "plugin": "@nx/rollup/plugin",
      "options": {
        "buildTargetName": "build"
      }
    }
  ]
}


// File: package.json
{
  "name": "@gigentic-frontend/source",
  "version": "0.0.1",
  "license": "MIT",
  "scripts": {
    "anchor": "nx run anchor:anchor",
    "anchor-build": "nx run anchor:anchor build",
    "anchor-keys": "nx run anchor:anchor keys sync",
    "anchor-test": "nx run anchor:test",
    "feature": "nx generate @solana-developers/preset-react:feature",
    "build": "nx build web",
    "dev": "nx serve web"
  },
  "private": true,
  "dependencies": {
    "@ai-sdk/openai": "^0.0.62",
    "@coral-xyz/anchor": "^0.30.1",
    "@langchain/core": "^0.3.3",
    "@solana-developers/preset-next": "3.1.0",
    "@solana/spl-token": "0.4.6",
    "@solana/wallet-adapter-base": "^0.9.23",
    "@solana/wallet-adapter-react": "^0.15.35",
    "@solana/wallet-adapter-react-ui": "^0.9.35",
    "@solana/web3.js": "1.91.9",
    "@tabler/icons-react": "3.5.0",
    "@tailwindcss/typography": "0.5.13",
    "@tanstack/react-query": "5.40.0",
    "@tanstack/react-query-next-experimental": "5.40.0",
    "ai": "3.4",
    "bs58": "5.0.0",
    "buffer": "6.0.3",
    "daisyui": "4.11.1",
    "encoding": "0.1.13",
    "jotai": "2.8.3",
    "langchain": "^0.3.2",
    "llamaindex": "^0.6.9",
    "next": "14.2.3",
    "react": "18.3.1",
    "react-dom": "18.3.1",
    "react-hot-toast": "2.4.1",
    "tslib": "^2.3.0",
    "zod": "^3.23.8"
  },
  "devDependencies": {
    "@nx/eslint": "19.3.2",
    "@nx/eslint-plugin": "19.3.2",
    "@nx/jest": "19.3.2",
    "@nx/js": "19.3.2",
    "@nx/next": "19.3.2",
    "@nx/rollup": "19.3.2",
    "@nx/workspace": "19.3.2",
    "@swc-node/register": "~1.9.1",
    "@swc/cli": "~0.3.12",
    "@swc/core": "~1.5.7",
    "@swc/helpers": "~0.5.11",
    "@swc/jest": "~0.2.36",
    "@types/jest": "^29.4.0",
    "@types/node": "18.16.9",
    "@types/pg": "^8.11.10",
    "@types/react": "18.3.1",
    "@types/react-dom": "18.3.0",
    "@typescript-eslint/eslint-plugin": "^7.3.0",
    "@typescript-eslint/parser": "^7.3.0",
    "autoprefixer": "10.4.13",
    "eslint": "~8.57.0",
    "eslint-config-next": "14.2.3",
    "eslint-config-prettier": "^9.0.0",
    "eslint-plugin-import": "2.27.5",
    "eslint-plugin-jsx-a11y": "6.7.1",
    "eslint-plugin-react": "7.32.2",
    "eslint-plugin-react-hooks": "4.6.0",
    "ignore": "^6.0.2",
    "jest": "^29.4.1",
    "jest-environment-jsdom": "^29.4.1",
    "nx": "19.3.2",
    "postcss": "8.4.38",
    "prettier": "^3.3.3",
    "prettier-plugin-rust": "^0.1.9",
    "rollup": "^4.14.0",
    "swc-loader": "0.1.15",
    "tailwindcss": "3.4.3",
    "ts-jest": "^29.1.0",
    "ts-node": "10.9.1",
    "typescript": "~5.4.2"
  }
}


// File: tsconfig.base.json
{
  "compileOnSave": false,
  "compilerOptions": {
    "rootDir": ".",
    "sourceMap": true,
    "declaration": false,
    "moduleResolution": "node",
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "importHelpers": true,
    "target": "es2015",
    "module": "esnext",
    "lib": ["es2020", "dom"],
    "skipLibCheck": true,
    "skipDefaultLibCheck": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./web/*"],
      "@gigentic-frontend/anchor": ["anchor/src/index.ts"]
    }
  },
  "exclude": ["node_modules", "tmp"]
}


// File: vercel.json
{
  "buildCommand": "yarn build",
  "outputDirectory": "dist/web/.next"
}

// File: web/.env.defaults
NEXT_PUBLIC_SERVICE_REGISTRY_KEYPAIR_SECRETKEY_BS58=base58-secret-key
NEXT_PUBLIC_SERVICE_REGISTRY_DEPLOYER_SECRETKEY_BS58=base58-secret-key
NEXT_PUBLIC_FEE_ACCOUNT_SECRETKEY_BS58=base58-secret-key

OPENAI_API_KEY=api-key


// File: web/.eslintrc.json
{
  "extends": [
    "plugin:@nx/react-typescript",
    "next",
    "next/core-web-vitals",
    "../.eslintrc.json"
  ],
  "ignorePatterns": ["!**/*", ".next/**/*"],
  "overrides": [
    {
      "files": ["*.ts", "*.tsx", "*.js", "*.jsx"],
      "rules": {
        "@next/next/no-html-link-for-pages": ["error", "web/pages"]
      }
    },
    {
      "files": ["*.ts", "*.tsx"],
      "rules": {}
    },
    {
      "files": ["*.js", "*.jsx"],
      "rules": {}
    },
    {
      "files": ["*.ts", "*.tsx", "*.js", "*.jsx"],
      "rules": {
        "@nx/enforce-module-boundaries": [
          "error",
          {
            "allow": ["@/"]
          }
        ]
      }
    }
  ]
}


// File: web/app/account/[address]/page.tsx
import AccountDetailFeature from '@/components/account/account-detail-feature';

export default function Page() {
  return <AccountDetailFeature />;
}


// File: web/app/account/page.tsx
import AccountListFeature from '@/components/account/account-list-feature';

export default function Page() {
  return <AccountListFeature />;
}


// File: web/app/api/chat/route.ts
import { openai } from '@ai-sdk/openai';
import { streamText, convertToCoreMessages } from 'ai';

// Allow streaming responses up to 30 seconds
export const maxDuration = 30;

export async function POST(req: Request) {
  const { messages } = await req.json();

  const result = await streamText({
    model: openai('gpt-4o-mini'),
    messages: convertToCoreMessages(messages),
  });

  return result.toDataStreamResponse();
}

// File: web/app/api/completion/route.ts
import { 
  convertToCoreMessages,
  Message as VercelChatMessage,
} from 'ai';


import { streamText } from "ai";
import { openai } from "@ai-sdk/openai";

export const maxDuration = 60;

const formatMessage = (message: VercelChatMessage) => {
  return `${message.role}: ${message.content}`;
};




export async function POST(req: Request) {
  const { messages }: { messages: VercelChatMessage[] } = await req.json();

  
    const result = await streamText({
      model: openai('gpt-4o'),
      messages: convertToCoreMessages(messages),
    });
  
    return result.toTextStreamResponse();

}





// File: web/app/api/hello/route.ts
export async function GET(request: Request) {
  return new Response('Hello, from API!');
}


// File: web/app/clusters/page.tsx
import ClusterFeature from '@/components/cluster/cluster-feature';

export default function Page() {
  return <ClusterFeature />;
}


// File: web/app/gigentic-frontend/page.tsx
import GigenticFrontendFeature from '@/components/gigentic-frontend/gigentic-frontend-feature';


export default function Page() {
  return <GigenticFrontendFeature />;
}



// File: web/app/global.css
@tailwind base;
@tailwind components;
@tailwind utilities;

html,
body {
  height: 100%;
}

.wallet-adapter-button-trigger {
  background: rgb(100, 26, 230) !important;
  border-radius: 8px !important;
  padding-left: 16px !important;
  padding-right: 16px !important;
}
.wallet-adapter-dropdown-list,
.wallet-adapter-button {
  font-family: inherit !important;
}


// File: web/app/layout.tsx
import './global.css';
import { UiLayout } from '@/components/ui/ui-layout';
import { ClusterProvider } from '@/components/cluster/cluster-data-access';
import { SolanaProvider } from '@/components/solana/solana-provider';
import { ReactQueryProvider } from './react-query-provider';

export const metadata = {
  title: 'gigentic-frontend',
  description: 'Gigentic is a decentralized platform to help humans and AI agents work together',
};

const links: { label: string; path: string }[] = [
  { label: 'Account', path: '/account' },
  { label: 'Clusters', path: '/clusters' },
  { label: 'Gigentic', path: '/gigentic-frontend' },
  { label: 'SearchAgent', path: '/search-agent' },
];

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body>
        <ReactQueryProvider>
          <ClusterProvider>
            <SolanaProvider>
              <UiLayout links={links}>{children}</UiLayout>
            </SolanaProvider>
          </ClusterProvider>
        </ReactQueryProvider>
      </body>
    </html>
  );
}


// File: web/app/page.module.css
.page {
}


// File: web/app/page.tsx
import DashboardFeature from '@/components/dashboard/dashboard-feature';

export default function Page() {
  return <DashboardFeature />;
}


// File: web/app/react-query-provider.tsx
'use client';

import React, { ReactNode, useState } from 'react';
import { ReactQueryStreamedHydration } from '@tanstack/react-query-next-experimental';
import { QueryClientProvider, QueryClient } from '@tanstack/react-query';

export function ReactQueryProvider({ children }: { children: ReactNode }) {
  const [client] = useState(new QueryClient());

  return (
    <QueryClientProvider client={client}>
      <ReactQueryStreamedHydration>{children}</ReactQueryStreamedHydration>
    </QueryClientProvider>
  );
}


// File: web/app/search-agent/page.tsx
import SearchAgent from '@/components/search-agent/search-agent';
import LlamaChat from '@/components/search-agent/llama-chat';


/*
export default function Page() {
  return <SearchAgent />;
} 
*/ 

export default function Page() {
  return <SearchAgent />;
}


// File: web/components/account/account-data-access.tsx
'use client';

import { useConnection, useWallet } from '@solana/wallet-adapter-react';
import { TOKEN_2022_PROGRAM_ID, TOKEN_PROGRAM_ID } from '@solana/spl-token';
import {
  Connection,
  LAMPORTS_PER_SOL,
  PublicKey,
  SystemProgram,
  TransactionMessage,
  TransactionSignature,
  VersionedTransaction,
} from '@solana/web3.js';
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import toast from 'react-hot-toast';
import { useTransactionToast } from '../ui/ui-layout';

export function useGetBalance({ address }: { address: PublicKey }) {
  const { connection } = useConnection();

  return useQuery({
    queryKey: ['get-balance', { endpoint: connection.rpcEndpoint, address }],
    queryFn: () => connection.getBalance(address),
  });
}

export function useGetSignatures({ address }: { address: PublicKey }) {
  const { connection } = useConnection();

  return useQuery({
    queryKey: ['get-signatures', { endpoint: connection.rpcEndpoint, address }],
    queryFn: () => connection.getSignaturesForAddress(address),
  });
}

export function useGetTokenAccounts({ address }: { address: PublicKey }) {
  const { connection } = useConnection();

  return useQuery({
    queryKey: [
      'get-token-accounts',
      { endpoint: connection.rpcEndpoint, address },
    ],
    queryFn: async () => {
      const [tokenAccounts, token2022Accounts] = await Promise.all([
        connection.getParsedTokenAccountsByOwner(address, {
          programId: TOKEN_PROGRAM_ID,
        }),
        connection.getParsedTokenAccountsByOwner(address, {
          programId: TOKEN_2022_PROGRAM_ID,
        }),
      ]);
      return [...tokenAccounts.value, ...token2022Accounts.value];
    },
  });
}

export function useTransferSol({ address }: { address: PublicKey }) {
  const { connection } = useConnection();
  const transactionToast = useTransactionToast();
  const wallet = useWallet();
  const client = useQueryClient();

  return useMutation({
    mutationKey: [
      'transfer-sol',
      { endpoint: connection.rpcEndpoint, address },
    ],
    mutationFn: async (input: { destination: PublicKey; amount: number }) => {
      let signature: TransactionSignature = '';
      try {
        const { transaction, latestBlockhash } = await createTransaction({
          publicKey: address,
          destination: input.destination,
          amount: input.amount,
          connection,
        });

        // Send transaction and await for signature
        signature = await wallet.sendTransaction(transaction, connection);

        // Send transaction and await for signature
        await connection.confirmTransaction(
          { signature, ...latestBlockhash },
          'confirmed'
        );

        console.log(signature);
        return signature;
      } catch (error: unknown) {
        console.log('error', `Transaction failed! ${error}`, signature);

        return;
      }
    },
    onSuccess: (signature) => {
      if (signature) {
        transactionToast(signature);
      }
      return Promise.all([
        client.invalidateQueries({
          queryKey: [
            'get-balance',
            { endpoint: connection.rpcEndpoint, address },
          ],
        }),
        client.invalidateQueries({
          queryKey: [
            'get-signatures',
            { endpoint: connection.rpcEndpoint, address },
          ],
        }),
      ]);
    },
    onError: (error) => {
      toast.error(`Transaction failed! ${error}`);
    },
  });
}

export function useRequestAirdrop({ address }: { address: PublicKey }) {
  const { connection } = useConnection();
  const transactionToast = useTransactionToast();
  const client = useQueryClient();

  return useMutation({
    mutationKey: ['airdrop', { endpoint: connection.rpcEndpoint, address }],
    // eslint-disable-next-line @typescript-eslint/no-inferrable-types
    mutationFn: async (amount: number = 1) => {
      const [latestBlockhash, signature] = await Promise.all([
        connection.getLatestBlockhash(),
        connection.requestAirdrop(address, amount * LAMPORTS_PER_SOL),
      ]);

      await connection.confirmTransaction(
        { signature, ...latestBlockhash },
        'confirmed'
      );
      return signature;
    },
    onSuccess: (signature) => {
      transactionToast(signature);
      return Promise.all([
        client.invalidateQueries({
          queryKey: [
            'get-balance',
            { endpoint: connection.rpcEndpoint, address },
          ],
        }),
        client.invalidateQueries({
          queryKey: [
            'get-signatures',
            { endpoint: connection.rpcEndpoint, address },
          ],
        }),
      ]);
    },
  });
}

async function createTransaction({
  publicKey,
  destination,
  amount,
  connection,
}: {
  publicKey: PublicKey;
  destination: PublicKey;
  amount: number;
  connection: Connection;
}): Promise<{
  transaction: VersionedTransaction;
  latestBlockhash: { blockhash: string; lastValidBlockHeight: number };
}> {
  // Get the latest blockhash to use in our transaction
  const latestBlockhash = await connection.getLatestBlockhash();

  // Create instructions to send, in this case a simple transfer
  const instructions = [
    SystemProgram.transfer({
      fromPubkey: publicKey,
      toPubkey: destination,
      lamports: amount * LAMPORTS_PER_SOL,
    }),
  ];

  // Create a new TransactionMessage with version and compile it to legacy
  const messageLegacy = new TransactionMessage({
    payerKey: publicKey,
    recentBlockhash: latestBlockhash.blockhash,
    instructions,
  }).compileToLegacyMessage();

  // Create a new VersionedTransaction which supports legacy and v0
  const transaction = new VersionedTransaction(messageLegacy);

  return {
    transaction,
    latestBlockhash,
  };
}


// File: web/components/account/account-detail-feature.tsx
'use client';

import { PublicKey } from '@solana/web3.js';
import { useMemo } from 'react';

import { useParams } from 'next/navigation';

import { ExplorerLink } from '../cluster/cluster-ui';
import { AppHero, ellipsify } from '../ui/ui-layout';
import {
  AccountBalance,
  AccountButtons,
  AccountTokens,
  AccountTransactions,
} from './account-ui';

export default function AccountDetailFeature() {
  const params = useParams();
  const address = useMemo(() => {
    if (!params.address) {
      return;
    }
    try {
      return new PublicKey(params.address);
    } catch (e) {
      console.log(`Invalid public key`, e);
    }
  }, [params]);
  if (!address) {
    return <div>Error loading account</div>;
  }

  return (
    <div>
      <AppHero
        title={<AccountBalance address={address} />}
        subtitle={
          <div className="my-4">
            <ExplorerLink
              path={`account/${address}`}
              label={ellipsify(address.toString())}
            />
          </div>
        }
      >
        <div className="my-4">
          <AccountButtons address={address} />
        </div>
      </AppHero>
      <div className="space-y-8">
        <AccountTokens address={address} />
        <AccountTransactions address={address} />
      </div>
    </div>
  );
}


// File: web/components/account/account-list-feature.tsx
'use client';

import { useWallet } from '@solana/wallet-adapter-react';
import { WalletButton } from '../solana/solana-provider';

import { redirect } from 'next/navigation';

export default function AccountListFeature() {
  const { publicKey } = useWallet();

  if (publicKey) {
    return redirect(`/account/${publicKey.toString()}`);
  }

  return (
    <div className="hero py-[64px]">
      <div className="hero-content text-center">
        <WalletButton />
      </div>
    </div>
  );
}


// File: web/components/account/account-ui.tsx
'use client';

import { useWallet } from '@solana/wallet-adapter-react';
import { LAMPORTS_PER_SOL, PublicKey } from '@solana/web3.js';
import { IconRefresh } from '@tabler/icons-react';
import { useQueryClient } from '@tanstack/react-query';
import { useMemo, useState } from 'react';
import { AppModal, ellipsify } from '../ui/ui-layout';
import { useCluster } from '../cluster/cluster-data-access';
import { ExplorerLink } from '../cluster/cluster-ui';
import {
  useGetBalance,
  useGetSignatures,
  useGetTokenAccounts,
  useRequestAirdrop,
  useTransferSol,
} from './account-data-access';

export function AccountBalance({ address }: { address: PublicKey }) {
  const query = useGetBalance({ address });

  return (
    <div>
      <h1
        className="text-5xl font-bold cursor-pointer"
        onClick={() => query.refetch()}
      >
        {query.data ? <BalanceSol balance={query.data} /> : '...'} SOL
      </h1>
    </div>
  );
}
export function AccountChecker() {
  const { publicKey } = useWallet();
  if (!publicKey) {
    return null;
  }
  return <AccountBalanceCheck address={publicKey} />;
}
export function AccountBalanceCheck({ address }: { address: PublicKey }) {
  const { cluster } = useCluster();
  const mutation = useRequestAirdrop({ address });
  const query = useGetBalance({ address });

  if (query.isLoading) {
    return null;
  }
  if (query.isError || !query.data) {
    return (
      <div className="alert alert-warning text-warning-content/80 rounded-none flex justify-center">
        <span>
          You are connected to <strong>{cluster.name}</strong> but your account
          is not found on this cluster.
        </span>
        <button
          className="btn btn-xs btn-neutral"
          onClick={() =>
            mutation.mutateAsync(1).catch((err) => console.log(err))
          }
        >
          Request Airdrop
        </button>
      </div>
    );
  }
  return null;
}

export function AccountButtons({ address }: { address: PublicKey }) {
  const wallet = useWallet();
  const { cluster } = useCluster();
  const [showAirdropModal, setShowAirdropModal] = useState(false);
  const [showReceiveModal, setShowReceiveModal] = useState(false);
  const [showSendModal, setShowSendModal] = useState(false);

  return (
    <div>
      <ModalAirdrop
        hide={() => setShowAirdropModal(false)}
        address={address}
        show={showAirdropModal}
      />
      <ModalReceive
        address={address}
        show={showReceiveModal}
        hide={() => setShowReceiveModal(false)}
      />
      <ModalSend
        address={address}
        show={showSendModal}
        hide={() => setShowSendModal(false)}
      />
      <div className="space-x-2">
        <button
          disabled={cluster.network?.includes('mainnet')}
          className="btn btn-xs lg:btn-md btn-outline"
          onClick={() => setShowAirdropModal(true)}
        >
          Airdrop
        </button>
        <button
          disabled={wallet.publicKey?.toString() !== address.toString()}
          className="btn btn-xs lg:btn-md btn-outline"
          onClick={() => setShowSendModal(true)}
        >
          Send
        </button>
        <button
          className="btn btn-xs lg:btn-md btn-outline"
          onClick={() => setShowReceiveModal(true)}
        >
          Receive
        </button>
      </div>
    </div>
  );
}

export function AccountTokens({ address }: { address: PublicKey }) {
  const [showAll, setShowAll] = useState(false);
  const query = useGetTokenAccounts({ address });
  const client = useQueryClient();
  const items = useMemo(() => {
    if (showAll) return query.data;
    return query.data?.slice(0, 5);
  }, [query.data, showAll]);

  return (
    <div className="space-y-2">
      <div className="justify-between">
        <div className="flex justify-between">
          <h2 className="text-2xl font-bold">Token Accounts</h2>
          <div className="space-x-2">
            {query.isLoading ? (
              <span className="loading loading-spinner"></span>
            ) : (
              <button
                className="btn btn-sm btn-outline"
                onClick={async () => {
                  await query.refetch();
                  await client.invalidateQueries({
                    queryKey: ['getTokenAccountBalance'],
                  });
                }}
              >
                <IconRefresh size={16} />
              </button>
            )}
          </div>
        </div>
      </div>
      {query.isError && (
        <pre className="alert alert-error">
          Error: {query.error?.message.toString()}
        </pre>
      )}
      {query.isSuccess && (
        <div>
          {query.data.length === 0 ? (
            <div>No token accounts found.</div>
          ) : (
            <table className="table border-4 rounded-lg border-separate border-base-300">
              <thead>
                <tr>
                  <th>Public Key</th>
                  <th>Mint</th>
                  <th className="text-right">Balance</th>
                </tr>
              </thead>
              <tbody>
                {items?.map(({ account, pubkey }) => (
                  <tr key={pubkey.toString()}>
                    <td>
                      <div className="flex space-x-2">
                        <span className="font-mono">
                          <ExplorerLink
                            label={ellipsify(pubkey.toString())}
                            path={`account/${pubkey.toString()}`}
                          />
                        </span>
                      </div>
                    </td>
                    <td>
                      <div className="flex space-x-2">
                        <span className="font-mono">
                          <ExplorerLink
                            label={ellipsify(account.data.parsed.info.mint)}
                            path={`account/${account.data.parsed.info.mint.toString()}`}
                          />
                        </span>
                      </div>
                    </td>
                    <td className="text-right">
                      <span className="font-mono">
                        {account.data.parsed.info.tokenAmount.uiAmount}
                      </span>
                    </td>
                  </tr>
                ))}

                {(query.data?.length ?? 0) > 5 && (
                  <tr>
                    <td colSpan={4} className="text-center">
                      <button
                        className="btn btn-xs btn-outline"
                        onClick={() => setShowAll(!showAll)}
                      >
                        {showAll ? 'Show Less' : 'Show All'}
                      </button>
                    </td>
                  </tr>
                )}
              </tbody>
            </table>
          )}
        </div>
      )}
    </div>
  );
}

export function AccountTransactions({ address }: { address: PublicKey }) {
  const query = useGetSignatures({ address });
  const [showAll, setShowAll] = useState(false);

  const items = useMemo(() => {
    if (showAll) return query.data;
    return query.data?.slice(0, 5);
  }, [query.data, showAll]);

  return (
    <div className="space-y-2">
      <div className="flex justify-between">
        <h2 className="text-2xl font-bold">Transaction History</h2>
        <div className="space-x-2">
          {query.isLoading ? (
            <span className="loading loading-spinner"></span>
          ) : (
            <button
              className="btn btn-sm btn-outline"
              onClick={() => query.refetch()}
            >
              <IconRefresh size={16} />
            </button>
          )}
        </div>
      </div>
      {query.isError && (
        <pre className="alert alert-error">
          Error: {query.error?.message.toString()}
        </pre>
      )}
      {query.isSuccess && (
        <div>
          {query.data.length === 0 ? (
            <div>No transactions found.</div>
          ) : (
            <table className="table border-4 rounded-lg border-separate border-base-300">
              <thead>
                <tr>
                  <th>Signature</th>
                  <th className="text-right">Slot</th>
                  <th>Block Time</th>
                  <th className="text-right">Status</th>
                </tr>
              </thead>
              <tbody>
                {items?.map((item) => (
                  <tr key={item.signature}>
                    <th className="font-mono">
                      <ExplorerLink
                        path={`tx/${item.signature}`}
                        label={ellipsify(item.signature, 8)}
                      />
                    </th>
                    <td className="font-mono text-right">
                      <ExplorerLink
                        path={`block/${item.slot}`}
                        label={item.slot.toString()}
                      />
                    </td>
                    <td>
                      {new Date((item.blockTime ?? 0) * 1000).toISOString()}
                    </td>
                    <td className="text-right">
                      {item.err ? (
                        <div
                          className="badge badge-error"
                          title={JSON.stringify(item.err)}
                        >
                          Failed
                        </div>
                      ) : (
                        <div className="badge badge-success">Success</div>
                      )}
                    </td>
                  </tr>
                ))}
                {(query.data?.length ?? 0) > 5 && (
                  <tr>
                    <td colSpan={4} className="text-center">
                      <button
                        className="btn btn-xs btn-outline"
                        onClick={() => setShowAll(!showAll)}
                      >
                        {showAll ? 'Show Less' : 'Show All'}
                      </button>
                    </td>
                  </tr>
                )}
              </tbody>
            </table>
          )}
        </div>
      )}
    </div>
  );
}

function BalanceSol({ balance }: { balance: number }) {
  return (
    <span>{Math.round((balance / LAMPORTS_PER_SOL) * 100000) / 100000}</span>
  );
}

function ModalReceive({
  hide,
  show,
  address,
}: {
  hide: () => void;
  show: boolean;
  address: PublicKey;
}) {
  return (
    <AppModal title="Receive" hide={hide} show={show}>
      <p>Receive assets by sending them to your public key:</p>
      <code>{address.toString()}</code>
    </AppModal>
  );
}

function ModalAirdrop({
  hide,
  show,
  address,
}: {
  hide: () => void;
  show: boolean;
  address: PublicKey;
}) {
  const mutation = useRequestAirdrop({ address });
  const [amount, setAmount] = useState('2');

  return (
    <AppModal
      hide={hide}
      show={show}
      title="Airdrop"
      submitDisabled={!amount || mutation.isPending}
      submitLabel="Request Airdrop"
      submit={() => mutation.mutateAsync(parseFloat(amount)).then(() => hide())}
    >
      <input
        disabled={mutation.isPending}
        type="number"
        step="any"
        min="1"
        placeholder="Amount"
        className="input input-bordered w-full"
        value={amount}
        onChange={(e) => setAmount(e.target.value)}
      />
    </AppModal>
  );
}

function ModalSend({
  hide,
  show,
  address,
}: {
  hide: () => void;
  show: boolean;
  address: PublicKey;
}) {
  const wallet = useWallet();
  const mutation = useTransferSol({ address });
  const [destination, setDestination] = useState('');
  const [amount, setAmount] = useState('1');

  if (!address || !wallet.sendTransaction) {
    return <div>Wallet not connected</div>;
  }

  return (
    <AppModal
      hide={hide}
      show={show}
      title="Send"
      submitDisabled={!destination || !amount || mutation.isPending}
      submitLabel="Send"
      submit={() => {
        mutation
          .mutateAsync({
            destination: new PublicKey(destination),
            amount: parseFloat(amount),
          })
          .then(() => hide());
      }}
    >
      <input
        disabled={mutation.isPending}
        type="text"
        placeholder="Destination"
        className="input input-bordered w-full"
        value={destination}
        onChange={(e) => setDestination(e.target.value)}
      />
      <input
        disabled={mutation.isPending}
        type="number"
        step="any"
        min="1"
        placeholder="Amount"
        className="input input-bordered w-full"
        value={amount}
        onChange={(e) => setAmount(e.target.value)}
      />
    </AppModal>
  );
}


// File: web/components/cluster/cluster-data-access.tsx
'use client';

import { clusterApiUrl, Connection } from '@solana/web3.js';
import { atom, useAtomValue, useSetAtom } from 'jotai';
import { atomWithStorage } from 'jotai/utils';
import { createContext, ReactNode, useContext } from 'react';
import toast from 'react-hot-toast';

export interface Cluster {
  name: string;
  endpoint: string;
  network?: ClusterNetwork;
  active?: boolean;
}

export enum ClusterNetwork {
  Mainnet = 'mainnet-beta',
  Testnet = 'testnet',
  Devnet = 'devnet',
  Custom = 'custom',
}

// By default, we don't configure the mainnet-beta cluster
// The endpoint provided by clusterApiUrl('mainnet-beta') does not allow access from the browser due to CORS restrictions
// To use the mainnet-beta cluster, provide a custom endpoint
export const defaultClusters: Cluster[] = [
  {
    name: 'devnet',
    endpoint: clusterApiUrl('devnet'),
    network: ClusterNetwork.Devnet,
  },
  { name: 'local', endpoint: 'http://localhost:8899' },
  {
    name: 'testnet',
    endpoint: clusterApiUrl('testnet'),
    network: ClusterNetwork.Testnet,
  },
];

const clusterAtom = atomWithStorage<Cluster>(
  'solana-cluster',
  defaultClusters[0]
);
const clustersAtom = atomWithStorage<Cluster[]>(
  'solana-clusters',
  defaultClusters
);

const activeClustersAtom = atom<Cluster[]>((get) => {
  const clusters = get(clustersAtom);
  const cluster = get(clusterAtom);
  return clusters.map((item) => ({
    ...item,
    active: item.name === cluster.name,
  }));
});

const activeClusterAtom = atom<Cluster>((get) => {
  const clusters = get(activeClustersAtom);

  return clusters.find((item) => item.active) || clusters[0];
});

export interface ClusterProviderContext {
  cluster: Cluster;
  clusters: Cluster[];
  addCluster: (cluster: Cluster) => void;
  deleteCluster: (cluster: Cluster) => void;
  setCluster: (cluster: Cluster) => void;
  getExplorerUrl(path: string): string;
}

const Context = createContext<ClusterProviderContext>(
  {} as ClusterProviderContext
);

export function ClusterProvider({ children }: { children: ReactNode }) {
  const cluster = useAtomValue(activeClusterAtom);
  const clusters = useAtomValue(activeClustersAtom);
  const setCluster = useSetAtom(clusterAtom);
  const setClusters = useSetAtom(clustersAtom);

  const value: ClusterProviderContext = {
    cluster,
    clusters: clusters.sort((a, b) => (a.name > b.name ? 1 : -1)),
    addCluster: (cluster: Cluster) => {
      try {
        new Connection(cluster.endpoint);
        setClusters([...clusters, cluster]);
      } catch (err) {
        toast.error(`${err}`);
      }
    },
    deleteCluster: (cluster: Cluster) => {
      setClusters(clusters.filter((item) => item.name !== cluster.name));
    },
    setCluster: (cluster: Cluster) => setCluster(cluster),
    getExplorerUrl: (path: string) =>
      `https://explorer.solana.com/${path}${getClusterUrlParam(cluster)}`,
  };
  return <Context.Provider value={value}>{children}</Context.Provider>;
}

export function useCluster() {
  return useContext(Context);
}

function getClusterUrlParam(cluster: Cluster): string {
  let suffix = '';
  switch (cluster.network) {
    case ClusterNetwork.Devnet:
      suffix = 'devnet';
      break;
    case ClusterNetwork.Mainnet:
      suffix = '';
      break;
    case ClusterNetwork.Testnet:
      suffix = 'testnet';
      break;
    default:
      suffix = `custom&customUrl=${encodeURIComponent(cluster.endpoint)}`;
      break;
  }

  return suffix.length ? `?cluster=${suffix}` : '';
}


// File: web/components/cluster/cluster-feature.tsx
'use client';

import { useState } from 'react';
import { AppHero } from '../ui/ui-layout';
import { ClusterUiModal } from './cluster-ui';
import { ClusterUiTable } from './cluster-ui';

export default function ClusterFeature() {
  const [showModal, setShowModal] = useState(false);

  return (
    <div>
      <AppHero
        title="Clusters"
        subtitle="Manage and select your Solana clusters"
      >
        <ClusterUiModal
          show={showModal}
          hideModal={() => setShowModal(false)}
        />
        <button
          className="btn btn-xs lg:btn-md btn-primary"
          onClick={() => setShowModal(true)}
        >
          Add Cluster
        </button>
      </AppHero>
      <ClusterUiTable />
    </div>
  );
}


// File: web/components/cluster/cluster-ui.tsx
'use client';

import { useConnection } from '@solana/wallet-adapter-react';
import { IconTrash } from '@tabler/icons-react';
import { useQuery } from '@tanstack/react-query';
import { ReactNode, useState } from 'react';
import { AppModal } from '../ui/ui-layout';
import { ClusterNetwork, useCluster } from './cluster-data-access';
import { Connection } from '@solana/web3.js';

export function ExplorerLink({
  path,
  label,
  className,
}: {
  path: string;
  label: string;
  className?: string;
}) {
  const { getExplorerUrl } = useCluster();
  return (
    <a
      href={getExplorerUrl(path)}
      target="_blank"
      rel="noopener noreferrer"
      className={className ? className : `link font-mono`}
    >
      {label}
    </a>
  );
}

export function ClusterChecker({ children }: { children: ReactNode }) {
  const { cluster } = useCluster();
  const { connection } = useConnection();

  const query = useQuery({
    queryKey: ['version', { cluster, endpoint: connection.rpcEndpoint }],
    queryFn: () => connection.getVersion(),
    retry: 1,
  });
  if (query.isLoading) {
    return null;
  }
  if (query.isError || !query.data) {
    return (
      <div className="alert alert-warning text-warning-content/80 rounded-none flex justify-center">
        <span>
          Error connecting to cluster <strong>{cluster.name}</strong>
        </span>
        <button
          className="btn btn-xs btn-neutral"
          onClick={() => query.refetch()}
        >
          Refresh
        </button>
      </div>
    );
  }
  return children;
}

export function ClusterUiSelect() {
  const { clusters, setCluster, cluster } = useCluster();
  return (
    <div className="dropdown dropdown-end">
      <label tabIndex={0} className="btn btn-primary rounded-btn">
        {cluster.name}
      </label>
      <ul
        tabIndex={0}
        className="menu dropdown-content z-[1] p-2 shadow bg-base-100 rounded-box w-52 mt-4"
      >
        {clusters.map((item) => (
          <li key={item.name}>
            <button
              className={`btn btn-sm ${
                item.active ? 'btn-primary' : 'btn-ghost'
              }`}
              onClick={() => setCluster(item)}
            >
              {item.name}
            </button>
          </li>
        ))}
      </ul>
    </div>
  );
}

export function ClusterUiModal({
  hideModal,
  show,
}: {
  hideModal: () => void;
  show: boolean;
}) {
  const { addCluster } = useCluster();
  const [name, setName] = useState('');
  const [network, setNetwork] = useState<ClusterNetwork | undefined>();
  const [endpoint, setEndpoint] = useState('');

  return (
    <AppModal
      title={'Add Cluster'}
      hide={hideModal}
      show={show}
      submit={() => {
        try {
          new Connection(endpoint);
          if (name) {
            addCluster({ name, network, endpoint });
            hideModal();
          } else {
            console.log('Invalid cluster name');
          }
        } catch {
          console.log('Invalid cluster endpoint');
        }
      }}
      submitLabel="Save"
    >
      <input
        type="text"
        placeholder="Name"
        className="input input-bordered w-full"
        value={name}
        onChange={(e) => setName(e.target.value)}
      />
      <input
        type="text"
        placeholder="Endpoint"
        className="input input-bordered w-full"
        value={endpoint}
        onChange={(e) => setEndpoint(e.target.value)}
      />
      <select
        className="select select-bordered w-full"
        value={network}
        onChange={(e) => setNetwork(e.target.value as ClusterNetwork)}
      >
        <option value={undefined}>Select a network</option>
        <option value={ClusterNetwork.Devnet}>Devnet</option>
        <option value={ClusterNetwork.Testnet}>Testnet</option>
        <option value={ClusterNetwork.Mainnet}>Mainnet</option>
      </select>
    </AppModal>
  );
}

export function ClusterUiTable() {
  const { clusters, setCluster, deleteCluster } = useCluster();
  return (
    <div className="overflow-x-auto">
      <table className="table border-4 border-separate border-base-300">
        <thead>
          <tr>
            <th>Name/ Network / Endpoint</th>
            <th className="text-center">Actions</th>
          </tr>
        </thead>
        <tbody>
          {clusters.map((item) => (
            <tr key={item.name} className={item?.active ? 'bg-base-200' : ''}>
              <td className="space-y-2">
                <div className="whitespace-nowrap space-x-2">
                  <span className="text-xl">
                    {item?.active ? (
                      item.name
                    ) : (
                      <button
                        title="Select cluster"
                        className="link link-secondary"
                        onClick={() => setCluster(item)}
                      >
                        {item.name}
                      </button>
                    )}
                  </span>
                </div>
                <span className="text-xs">
                  Network: {item.network ?? 'custom'}
                </span>
                <div className="whitespace-nowrap text-gray-500 text-xs">
                  {item.endpoint}
                </div>
              </td>
              <td className="space-x-2 whitespace-nowrap text-center">
                <button
                  disabled={item?.active}
                  className="btn btn-xs btn-default btn-outline"
                  onClick={() => {
                    if (!window.confirm('Are you sure?')) return;
                    deleteCluster(item);
                  }}
                >
                  <IconTrash size={16} />
                </button>
              </td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}


// File: web/components/dashboard/dashboard-feature.tsx
'use client';

import { AppHero } from '../ui/ui-layout';

const links: { label: string; href: string }[] = [
  { label: 'Solana Docs', href: 'https://docs.solana.com/' },
  { label: 'Solana Faucet', href: 'https://faucet.solana.com/' },
  { label: 'Solana Cookbook', href: 'https://solanacookbook.com/' },
  { label: 'Solana Stack Overflow', href: 'https://solana.stackexchange.com/' },
  {
    label: 'Solana Developers GitHub',
    href: 'https://github.com/solana-developers/',
  },
];

export default function DashboardFeature() {
  return (
    <div>
      <AppHero title="gm" subtitle="Say hi to your new Solana dApp." />
      <div className="max-w-xl mx-auto py-6 sm:px-6 lg:px-8 text-center">
        <div className="space-y-2">
          <p>Here are some helpful links to get you started.</p>
          {links.map((link, index) => (
            <div key={index}>
              <a
                href={link.href}
                className="link"
                target="_blank"
                rel="noopener noreferrer"
              >
                {link.label}
              </a>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}


// File: web/components/gigentic-frontend/gigentic-frontend-data-access.tsx
'use client';

import bs58 from 'bs58';

import {
  getGigenticProgram,
  getGigenticProgramId,
} from '@gigentic-frontend/anchor';

import { useMemo } from 'react';
import toast from 'react-hot-toast';

// import { Program } from '@coral-xyz/anchor';
import {
  Connection,
  LAMPORTS_PER_SOL,
  Cluster,
  Keypair,
  PublicKey,
} from '@solana/web3.js';
import { useConnection } from '@solana/wallet-adapter-react';
import { useMutation, useQuery } from '@tanstack/react-query';
import { useAnchorProvider } from '../solana/solana-provider';
import { useCluster } from '../cluster/cluster-data-access';

import { useTransactionToast } from '../ui/ui-layout';

// // Helper function to parse keypair from environment variable
// const parseKeypair = (key: string): Keypair => {
//   const keypairString = process.env[key];
//   if (!keypairString) {
//     throw new Error(`Environment variable ${key} is not set`);
//   }
//   // console.log('keypairString', keypairString);
//   const keypair = Keypair.fromSecretKey(bs58.decode(keypairString));

//   return keypair;
// };

// export const SERVICE_REGISTRY_SPACE = 10_000_000;
// export const FEE_PERCENTAGE = 0;

// // SEEDS
// // export const SOME_SEED: string = "some-registry";

// // KEYPAIRS - Setup Service Registry Accounts

// // export const SERVICE_REGISTRY_DEPLOYER = Keypair.generate();
// export const SERVICE_REGISTRY_DEPLOYER = parseKeypair(
//   'NEXT_PUBLIC_SERVICE_REGISTRY_DEPLOYER_SECRETKEY_BS58',
// );

// // export const SERVICE_REGISTRY_KEYPAIR = Keypair.generate();
// export const SERVICE_REGISTRY_KEYPAIR = parseKeypair(
//   'NEXT_PUBLIC_SERVICE_REGISTRY_KEYPAIR_SECRETKEY_BS58',
// );

// export const FEE_ACCOUNT = parseKeypair(
//   'NEXT_PUBLIC_FEE_ACCOUNT_SECRETKEY_BS58',
// );

// // export const REGISTRY_KEYPAIR = process.env.NEXT_PUBLIC_SERVICE_REGISTRY_DEPLOYER;
// export const REGISTRY_KEYPAIR = Keypair.generate();

// export const MINT_AUTHORITY: Keypair = Keypair.generate();

// // export const MINT_AUTHORITY = parseKeypair('REACT_APP_MINT_AUTHORITY_KEYPAIR');

// export const SERVICE_DEPLOYERS: Keypair[] = [
//   Keypair.generate(),
//   Keypair.generate(),
//   Keypair.generate(),
// ];

// export const SERVICE_USERS: Keypair[] = [
//   Keypair.generate(),
//   Keypair.generate(),
//   Keypair.generate(),
// ];

/**
 * Funds a given account with SOL via an airdrop.
 *
 * @param {Connection} connection - The Solana network connection.
 * @param {PublicKey} pubkey - The public key of the account to be funded.
 */
export async function fund_account(connection: Connection, pubkey: PublicKey) {
  // Request an airdrop of 1000 SOL (specified in lamports, where 1 SOL = 10^9 lamports)
  const airdropSignature = await connection.requestAirdrop(
    pubkey,
    LAMPORTS_PER_SOL * 1000,
  );

  // Fetch the latest blockhash and last valid block height required for transaction confirmation
  const latestBlockhash = await connection.getLatestBlockhash();

  // Confirm the transaction using the airdrop signature and the latest blockhash information
  await connection.confirmTransaction({
    signature: airdropSignature, // The signature of the airdrop transaction
    blockhash: latestBlockhash.blockhash, // Latest blockhash to ensure transaction validity
    lastValidBlockHeight: latestBlockhash.lastValidBlockHeight, // The height up to which the blockhash is valid
  });
}

export async function fundAndLogAccount(
  connection: Connection,
  account: Keypair,
  accountName: string,
) {
  try {
    await fund_account(connection, account.publicKey);
    const balance = await connection.getBalance(account.publicKey);
    console.log(
      `${accountName} (${account.publicKey.toBase58().slice(0, 8)}): ${
        balance / LAMPORTS_PER_SOL
      } SOL`,
    );
  } catch (error) {
    console.error(`Error funding ${accountName}:`, error);
  }
}

export function useGigenticProgram() {
  const { connection } = useConnection();
  const { cluster } = useCluster();
  const transactionToast = useTransactionToast();
  const provider = useAnchorProvider();
  const programId = useMemo(
    () => getGigenticProgramId(cluster.network as Cluster),
    [cluster],
  );
  const program = getGigenticProgram(provider);

  // const accounts = useQuery({
  //   queryKey: ['gigentic', 'all', { cluster }],
  //   queryFn: () => program.account.gigentic.all(),
  // });

  // const getProgramAccount = useQuery({
  //   queryKey: ['get-program-account', { cluster }],
  //   queryFn: () => connection.getParsedAccountInfo(programId),
  // });

  // const initialize = useMutation({
  //   mutationKey: ['gigentic', 'initialize', { cluster }],
  //   mutationFn: (keypair: Keypair) =>
  //     program.methods
  //       .initialize()
  //       .accounts({ gigentic: keypair.publicKey })
  //       .signers([keypair])
  //       .rpc(),
  //   onSuccess: (signature) => {
  //     transactionToast(signature);
  //     return accounts.refetch();
  //   },
  //   onError: () => toast.error('Failed to initialize account'),
  // });

  return {
    program,
    programId,
    // accounts,
    // getProgramAccount,
    // initialize,
  };
}

// export function useGigenticProgramAccount({ account }: { account: PublicKey }) {
//   const { cluster } = useCluster();
//   const transactionToast = useTransactionToast();
//   const { program, accounts } = useGigenticProgram();

//   const accountQuery = useQuery({
//     queryKey: ['gigentic-frontend', 'fetch', { cluster, account }],
//     queryFn: () => program.account.gigentic.fetch(account),
//   });

//   const closeMutation = useMutation({
//     mutationKey: ['gigentic-frontend', 'close', { cluster, account }],
//     mutationFn: () =>
//       program.methods.close().accounts({ gigentic: account }).rpc(),
//     onSuccess: (tx) => {
//       transactionToast(tx);
//       return accounts.refetch();
//     },
//   });

//   const decrementMutation = useMutation({
//     mutationKey: ['gigentic-frontend', 'decrement', { cluster, account }],
//     mutationFn: () =>
//       program.methods.decrement().accounts({ gigentic: account }).rpc(),
//     onSuccess: (tx) => {
//       transactionToast(tx);
//       return accountQuery.refetch();
//     },
//   });

//   const incrementMutation = useMutation({
//     mutationKey: ['gigentic-frontend', 'increment', { cluster, account }],
//     mutationFn: () =>
//       program.methods.increment().accounts({ gigentic: account }).rpc(),
//     onSuccess: (tx) => {
//       transactionToast(tx);
//       return accountQuery.refetch();
//     },
//   });

//   const setMutation = useMutation({
//     mutationKey: ['gigentic-frontend', 'set', { cluster, account }],
//     mutationFn: (value: number) =>
//       program.methods.set(value).accounts({ gigentic: account }).rpc(),
//     onSuccess: (tx) => {
//       transactionToast(tx);
//       return accountQuery.refetch();
//     },
//   });

//   return {
//     accountQuery,
//     closeMutation,
//     decrementMutation,
//     incrementMutation,
//     setMutation,
//   };
// }


// File: web/components/gigentic-frontend/gigentic-frontend-feature-orig.tsx
'use client';

import { useWallet } from '@solana/wallet-adapter-react';
import { WalletButton } from '../solana/solana-provider';
import { AppHero, ellipsify } from '../ui/ui-layout';
import { ExplorerLink } from '../cluster/cluster-ui';
import { useGigenticProgram } from './gigentic-frontend-data-access';
import {
  GigenticFrontendCreate,
  // GigenticFrontendList,
} from './gigentic-frontend-ui';

export default function GigenticFrontendFeature() {
  const { publicKey } = useWallet();
  const { programId } = useGigenticProgram();

  return publicKey ? (
    <div>
      <AppHero
        title="GigenticFrontend"
        subtitle={
          'Create a new account by clicking the "Create" button. The state of a account is stored on-chain and can be manipulated by calling the program\'s methods (increment, decrement, set, and close).'
        }
      >
        <p className="mb-6">
          <ExplorerLink
            path={`account/${programId}`}
            label={ellipsify(programId.toString())}
          />
        </p>
        <GigenticFrontendCreate />
      </AppHero>
      {/* <GigenticFrontendList /> */}
    </div>
  ) : (
    <div className="max-w-4xl mx-auto">
      <div className="hero py-[64px]">
        <div className="hero-content text-center">
          <WalletButton />
        </div>
      </div>
    </div>
  );
}


// File: web/components/gigentic-frontend/gigentic-frontend-feature.tsx
'use client';

// React
import { useState } from 'react';

// Solana
import {
  PublicKey,
  Keypair,
  LAMPORTS_PER_SOL,
  Transaction,
  SystemProgram,
  sendAndConfirmTransaction,
} from '@solana/web3.js';

// Local Wallet Provider Setup
import { useWallet, useConnection } from '@solana/wallet-adapter-react';
import { WalletButton } from '../solana/solana-provider';

// UI
import { AppHero, ellipsify, useTransactionToast } from '../ui/ui-layout';
import { ExplorerLink } from '../cluster/cluster-ui';
import {
  GigenticFrontendCreate,
  // GigenticFrontendList,
} from './gigentic-frontend-ui';

// Program Data Access
import {
  useGigenticProgram,
  fundAndLogAccount,
  // SERVICE_REGISTRY_SPACE,
  // SERVICE_REGISTRY_DEPLOYER,
  // SERVICE_REGISTRY_KEYPAIR,
  // REGISTRY_KEYPAIR,
  // FEE_ACCOUNT,
  // FEE_PERCENTAGE,
  // MINT_AUTHORITY,
  // SERVICE_DEPLOYERS,
} from './gigentic-frontend-data-access';

export function InitializeServiceRegistry() {
  const { connection } = useConnection();
  const { program } = useGigenticProgram();

  const { publicKey, sendTransaction } = useWallet();

  const [feeAccount, setFeeAccount] = useState('');
  const [feePercentage, setFeePercentage] = useState('');
  const [feeAccountSecretKey, setFeeAccountSecretKey] = useState('');

  const transactionToast = useTransactionToast();

  const handleFundAccounts = async () => {
    console.log('Fund necessary accounts with SOL:');

    // await fundAndLogAccount(
    //   connection,
    //   SERVICE_REGISTRY_DEPLOYER,
    //   'SERVICE_REGISTRY_DEPLOYER',
    // );

    // await fundAndLogAccount(connection, MINT_AUTHORITY, 'MINT_AUTHORITY');

    // for (let i = 0; i < SERVICE_DEPLOYERS.length; i++) {
    //   await fundAndLogAccount(
    //     connection,
    //     SERVICE_DEPLOYERS[i],
    //     `SERVICE_DEPLOYER ${i}`
    //   );
    // }
  };

  const handleSetUpRegistryAccount = async () => {
    console.log('Set up accounts for the Service Registry');
    console.log(
      process.env.NEXT_PUBLIC_SERVICE_REGISTRY_KEYPAIR_SECRETKEY_BS58,
    );

    // // Calculate the minimum balance required for rent exemption for an account of a given size.
    // // This prevents the account from being deleted due to insufficient balance.
    // const rentExemptionAmount =
    //   await connection.getMinimumBalanceForRentExemption(
    //     SERVICE_REGISTRY_SPACE,
    //   );
    // console.log('rentExemptionAmount', rentExemptionAmount);

    // // Prepare the parameters needed to create a new account on the Solana blockchain.
    // const createAccountParams = {
    //   fromPubkey: SERVICE_REGISTRY_DEPLOYER.publicKey, // Account paying for the creation of the new account
    //   newAccountPubkey: SERVICE_REGISTRY_KEYPAIR.publicKey, // Public key of the new account to be created
    //   lamports: rentExemptionAmount, // Amount of SOL (in lamports) to transfer for rent exemption
    //   space: SERVICE_REGISTRY_SPACE, // Amount of space (in bytes) to allocate for the new account
    //   programId: program.programId, // The program that owns this account (in this case, the service registry program)
    // };
    // console.log(
    //   'SERVICE_REGISTRY_DEPLOYER',
    //   SERVICE_REGISTRY_DEPLOYER.publicKey.toBase58(),
    // );
    // console.log(
    //   'SERVICE_REGISTRY_KEYPAIR',
    //   SERVICE_REGISTRY_KEYPAIR.publicKey.toBase58(),
    // );

    // // Create a new transaction and add an instruction to create a new account.
    // const createAccountTransaction = new Transaction().add(
    //   SystemProgram.createAccount(createAccountParams),
    // );

    // try {
    //   // Send the transaction and wait for confirmation.
    //   // Both SERVICE_REGISTRY_DEPLOYER and SERVICE_REGISTRY_KEYPAIR need to sign the transaction.
    //   const tx = await sendAndConfirmTransaction(
    //     connection,
    //     createAccountTransaction,
    //     [SERVICE_REGISTRY_DEPLOYER, SERVICE_REGISTRY_KEYPAIR],
    //   );
    //   transactionToast(tx);
    //   console.log('Service Registry account setup with transaction:', tx);
    // } catch (error) {
    //   console.error('Error setting up Service Registry accounts:', error);
    // }
  };

  const handleInitializeRegistry = async () => {
    if (!publicKey) {
      console.error('Wallet not connected');
      return;
    }

    //   // Convert feePercentage to a number and validate
    //   const feePercentageNumber = parseInt(feePercentage);
    //   if (
    //     isNaN(feePercentageNumber) ||
    //     feePercentageNumber < 0 ||
    //     feePercentageNumber > 100
    //   ) {
    //     console.error('Invalid fee percentage');
    //     return;
    //   }

    //   console.log(
    //     'SERVICE_REGISTRY_DEPLOYER',
    //     SERVICE_REGISTRY_DEPLOYER.publicKey.toBase58(),
    //   );
    //   console.log('Wallet publicKey', publicKey.toBase58());

    //   console.log(
    //     'serviceRegistry',
    //     SERVICE_REGISTRY_KEYPAIR.publicKey.toBase58(),
    //   );

    //   try {
    //     const tx = await program.methods
    //       .initializeServiceRegistry(FEE_ACCOUNT.publicKey, feePercentageNumber) //  sets the fee_Account owner to the deployer, and for now sets the initial fee to 0
    //       .accounts({
    //         initializer: SERVICE_REGISTRY_DEPLOYER.publicKey, // Account that initializes the registry
    //         serviceRegistry: SERVICE_REGISTRY_KEYPAIR.publicKey, // The new service registry account being initialized
    //       })
    //       .transaction();

    //     const signature = await sendTransaction(tx, connection);
    //     transactionToast(signature);
    //     console.log('Transaction confirmed:', signature);
    //   } catch (error) {
    //     console.error('Error sending transaction:', error);
    //   }
    // };

    // const handleCheckRegistry = async () => {
    //   console.log(
    //     'serviceRegistry',
    //     SERVICE_REGISTRY_KEYPAIR.publicKey.toBase58(),
    //   );

    //   // Fetch the service registry account data
    //   const fetchedRegistryAccount = await program.account.serviceRegistry.fetch(
    //     SERVICE_REGISTRY_KEYPAIR.publicKey,
    //   );
    //   console.log(
    //     'Fetched Fee account from Registry:',
    //     fetchedRegistryAccount.feeAccount.toBase58(),
    //   );
    //   console.log(
    //     'Fetched Fee percentage from Registry:',
    //     fetchedRegistryAccount.feePercentage,
    //   );

    // // Additional checks if needed
    // console.log(
    //   'Service account addresses:',
    //   fetchedRegistryAccount.serviceAccountAddresses
    // );
  };

  return (
    <div className="bg-blue-100 p-6 rounded-lg shadow-md max-w-xl mx-auto">
      <h2 className="text-2xl font-bold mb-4 text-blue-900">
        Initialize Service Registry
      </h2>

      {/* <input
        type="text"
        placeholder="Fee Account Public Key"
        value={FEE_ACCOUNT.publicKey.toBase58()}
        onChange={(e) => setFeeAccount(e.target.value)}
        className="w-full p-2 mb-3 border border-blue-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
      /> */}
      <input
        type="number"
        placeholder="Fee Percentage (0-100)"
        value={feePercentage}
        onChange={(e) => setFeePercentage(e.target.value)}
        className="w-full p-2 mb-4 border border-blue-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
      />
      <div className="flex space-x-4 mb-4">
        <button
          onClick={handleFundAccounts}
          disabled={!publicKey}
          className="flex-1 bg-blue-800 text-white py-2 px-4 rounded hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-700 disabled:opacity-50 disabled:cursor-not-allowed"
        >
          Fund Accounts
        </button>{' '}
        <button
          onClick={handleSetUpRegistryAccount}
          disabled={!publicKey}
          className="flex-1 bg-blue-800 text-white py-2 px-4 rounded hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-700 disabled:opacity-50 disabled:cursor-not-allowed"
        >
          Setup Accounts
        </button>
      </div>
      <div className="flex space-x-4">
        <button
          onClick={handleInitializeRegistry}
          disabled={!publicKey}
          className="flex-1 bg-blue-800 text-white py-2 px-4 rounded hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-700 disabled:opacity-50 disabled:cursor-not-allowed"
        >
          Init Registry
        </button>
        {/* <button
          onClick={handleCheckRegistry}
          disabled={!publicKey}
          className="flex-1 bg-blue-800 text-white py-2 px-4 rounded hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-700 disabled:opacity-50 disabled:cursor-not-allowed"
        >
          Check Registry
        </button> */}
      </div>
    </div>
  );
}

export default function GigenticFrontendFeature() {
  const { publicKey } = useWallet();
  const { programId } = useGigenticProgram();

  return publicKey ? (
    <div>
      <AppHero
        title="Gigentic"
        subtitle={
          'Gigentic is a decentralized platform to help humans and AI agents work together in a frictionless way with trust-minimized payment flows and verifiable ratings.'
        }
      >
        <p className="mb-6">
          <ExplorerLink
            path={`account/${programId}`}
            label={ellipsify(programId.toString())}
          />
        </p>

        <GigenticFrontendCreate />
      </AppHero>
      <InitializeServiceRegistry />
    </div>
  ) : (
    <div className="max-w-4xl mx-auto">
      <div className="hero py-[64px]">
        <div className="hero-content text-center">
          <WalletButton />
        </div>
      </div>
    </div>
  );
}


// File: web/components/gigentic-frontend/gigentic-frontend-ui.tsx
'use client';

import { Keypair, PublicKey } from '@solana/web3.js';
import { useMemo } from 'react';
import { ellipsify } from '../ui/ui-layout';
import { ExplorerLink } from '../cluster/cluster-ui';
import {
  useGigenticProgram,
  // useGigenticProgramAccount,
} from './gigentic-frontend-data-access';

export function GigenticFrontendCreate() {
  // const { initialize } = useGigenticProgram();

  return (
    <p>
      Hello from Gigentic MVP Frontend! This is where we first interact with the
      Gigentic program.
      {process.env.NEXT_PUBLIC_SERVICE_REGISTRY_KEYPAIR_SECRETKEY_BS58}
    </p>

    // <button
    //   className="btn btn-xs lg:btn-md btn-primary"
    //   onClick={() => initialize.mutateAsync(Keypair.generate())}
    //   disabled={initialize.isPending}
    // >
    //   Create {initialize.isPending && '...'}
    // </button>
  );
}

// export function GigenticFrontendList() {
//   const { accounts, getProgramAccount } = useGigenticProgram();

//   if (getProgramAccount.isLoading) {
//     return <span className="loading loading-spinner loading-lg"></span>;
//   }
//   if (!getProgramAccount.data?.value) {
//     return (
//       <div className="alert alert-info flex justify-center">
//         <span>
//           Program account not found. Make sure you have deployed the program and
//           are on the correct cluster.
//         </span>
//       </div>
//     );
//   }
//   return (
//     <div className={'space-y-6'}>
//       {accounts.isLoading ? (
//         <span className="loading loading-spinner loading-lg"></span>
//       ) : accounts.data?.length ? (
//         <div className="grid md:grid-cols-2 gap-4">
//           {accounts.data?.map((account) => (
//             <GigenticFrontendCard
//               key={account.publicKey.toString()}
//               account={account.publicKey}
//             />
//           ))}
//         </div>
//       ) : (
//         <div className="text-center">
//           <h2 className={'text-2xl'}>No accounts</h2>
//           No accounts found. Create one above to get started.
//         </div>
//       )}
//     </div>
//   );
// }

// function GigenticFrontendCard({ account }: { account: PublicKey }) {
//   const {
//     accountQuery,
//     incrementMutation,
//     setMutation,
//     decrementMutation,
//     closeMutation,
//   } = useGigenticProgramAccount({ account });

//   const count = useMemo(
//     () => accountQuery.data?.count ?? 0,
//     [accountQuery.data?.count],
//   );

//   return accountQuery.isLoading ? (
//     <span className="loading loading-spinner loading-lg"></span>
//   ) : (
//     <div className="card card-bordered border-base-300 border-4 text-neutral-content">
//       <div className="card-body items-center text-center">
//         <div className="space-y-6">
//           <h2
//             className="card-title justify-center text-3xl cursor-pointer"
//             onClick={() => accountQuery.refetch()}
//           >
//             {count}
//           </h2>
//           <div className="card-actions justify-around">
//             <button
//               className="btn btn-xs lg:btn-md btn-outline"
//               onClick={() => incrementMutation.mutateAsync()}
//               disabled={incrementMutation.isPending}
//             >
//               Increment
//             </button>
//             <button
//               className="btn btn-xs lg:btn-md btn-outline"
//               onClick={() => {
//                 const value = window.prompt(
//                   'Set value to:',
//                   count.toString() ?? '0',
//                 );
//                 if (
//                   !value ||
//                   parseInt(value) === count ||
//                   isNaN(parseInt(value))
//                 ) {
//                   return;
//                 }
//                 return setMutation.mutateAsync(parseInt(value));
//               }}
//               disabled={setMutation.isPending}
//             >
//               Set
//             </button>
//             <button
//               className="btn btn-xs lg:btn-md btn-outline"
//               onClick={() => decrementMutation.mutateAsync()}
//               disabled={decrementMutation.isPending}
//             >
//               Decrement
//             </button>
//           </div>
//           <div className="text-center space-y-4">
//             <p>
//               <ExplorerLink
//                 path={`account/${account}`}
//                 label={ellipsify(account.toString())}
//               />
//             </p>
//             <button
//               className="btn btn-xs btn-secondary btn-outline"
//               onClick={() => {
//                 if (
//                   !window.confirm(
//                     'Are you sure you want to close this account?',
//                   )
//                 ) {
//                   return;
//                 }
//                 return closeMutation.mutateAsync();
//               }}
//               disabled={closeMutation.isPending}
//             >
//               Close
//             </button>
//           </div>
//         </div>
//       </div>
//     </div>
//   );
// }


// File: web/components/search-agent/llama-chat.tsx
'use client';

import { useCompletion } from 'ai/react';
import { useEffect, useRef, useState } from 'react';

export default function LlamaChat() {
    const { completion, input, handleInputChange, handleSubmit, setInput } = useCompletion();
    const [messages, setMessages] = useState<{ id: number, role: string, content: string }[]>([]);
    const [streamingMessage, setStreamingMessage] = useState<string>('');
    const messagesEndRef = useRef<HTMLDivElement>(null);

    const scrollToBottom = () => {
        if (messagesEndRef.current) {
            messagesEndRef.current.scrollIntoView({ behavior: 'smooth' });
        }
    };

    useEffect(() => {
        if (completion) {
            console.log('Completion:', completion);
            setStreamingMessage(completion);
        }
    }, [completion]);

    useEffect(() => {
        if (streamingMessage) {
            setMessages(prevMessages => {
                const lastMessage = prevMessages[prevMessages.length - 1];
                if (lastMessage && lastMessage.role === 'AI') {
                    return [
                        ...prevMessages.slice(0, -1),
                        { ...lastMessage, content: streamingMessage }
                    ];
                } else {
                    return [
                        ...prevMessages,
                        { id: prevMessages.length, role: 'AI', content: streamingMessage }
                    ];
                }
            });
        }
    }, [streamingMessage]);

    const handleUserSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        const newMessage = { id: messages.length, role: 'user', content: input };
        setMessages(prevMessages => [...prevMessages, newMessage]);
        setStreamingMessage(''); // Reset streaming message

        // Ensure handleSubmit can accept the full prompt
        await handleSubmit(e);
        setInput(''); // Clear the input field
    };

    useEffect(() => {
        scrollToBottom();
    }, [messages]);

    return (
        <div className="bg-blue-100 p-4 rounded-lg shadow-md w-full max-w-4xl mx-auto flex flex-col max-h-[80vh]">
            <h2 className="text-2xl font-bold mb-4 text-blue-900">
                Search Agent
            </h2>
            <div className="flex flex-col w-full flex-grow overflow-y-auto text-gray-900">
                {messages.map(m => (
                    <div key={m.id} className="whitespace-pre-wrap">
                        {m.role === 'user' ? 'User: ' : 'AI: '}
                        {m.content}
                    </div>
                ))}
                <div ref={messagesEndRef} />
            </div>
            <form onSubmit={handleUserSubmit} className="mt-4 w-full">
                <input
                    className="w-full p-2 border border-gray-300 rounded shadow-xl"
                    value={input}
                    placeholder="Say something..."
                    onChange={handleInputChange}
                />
            </form>
        </div>
    );
}


// File: web/components/search-agent/search-agent.tsx
'use client';

import { useChat } from 'ai/react';
import { useEffect, useRef } from 'react';



export default function SearchAgent() {
  const { messages, input, handleInputChange, handleSubmit, error } = useChat(
      {
        api: '/api/completion',
        streamProtocol: 'text',
        onError: (error) => {
          console.error("Chat error:", error);
        }
      }
  );

  const messagesEndRef = useRef<HTMLDivElement>(null);

  const scrollToBottom = () => {
    if (messagesEndRef.current) {
      messagesEndRef.current.scrollIntoView({ behavior: 'smooth' });
    }
  };
  
  useEffect(() => {
    scrollToBottom();
  }, [messages]);

  return (
    
    <div className="bg-blue-100 p-4 rounded-lg shadow-md w-full max-w-4xl mx-auto flex flex-col max-h-[80vh]">
      <h2 className="text-2xl font-bold mb-4 text-blue-900">
        Search Agent
      </h2>
      <div className="flex flex-col w-full flex-grow overflow-y-auto text-gray-900">
        
        {messages.map((m, index) => (
          <div key={index} className="whitespace-pre-wrap">
            {m.content}
          </div>
        ))}
        {error && <div className="text-red-500">Error: {error.message}</div>}
        <div ref={messagesEndRef} />
      </div>
      <form onSubmit={handleSubmit} className="mt-4 w-full">
        <input
          className="w-full p-2 border border-gray-300 rounded shadow-xl"
          value={input}
          placeholder="Search Agent - Say something..."
          onChange={handleInputChange}
        />
      </form>
    </div>
    
    
  );
}









// File: web/components/solana/solana-provider.tsx
'use client';

import dynamic from 'next/dynamic';
import { AnchorProvider } from '@coral-xyz/anchor';
import { WalletError } from '@solana/wallet-adapter-base';
import {
  AnchorWallet,
  useConnection,
  useWallet,
  ConnectionProvider,
  WalletProvider,
} from '@solana/wallet-adapter-react';
import { WalletModalProvider } from '@solana/wallet-adapter-react-ui';
import { ReactNode, useCallback, useMemo } from 'react';
import { useCluster } from '../cluster/cluster-data-access';

require('@solana/wallet-adapter-react-ui/styles.css');

export const WalletButton = dynamic(
  async () =>
    (await import('@solana/wallet-adapter-react-ui')).WalletMultiButton,
  { ssr: false }
);

export function SolanaProvider({ children }: { children: ReactNode }) {
  const { cluster } = useCluster();
  const endpoint = useMemo(() => cluster.endpoint, [cluster]);
  const onError = useCallback((error: WalletError) => {
    console.error(error);
  }, []);

  return (
    <ConnectionProvider endpoint={endpoint}>
      <WalletProvider wallets={[]} onError={onError} autoConnect={true}>
        <WalletModalProvider>{children}</WalletModalProvider>
      </WalletProvider>
    </ConnectionProvider>
  );
}

export function useAnchorProvider() {
  const { connection } = useConnection();
  const wallet = useWallet();

  return new AnchorProvider(connection, wallet as AnchorWallet, {
    commitment: 'confirmed',
  });
}


// File: web/components/ui/ui-layout.tsx
'use client';

import { WalletButton } from '../solana/solana-provider';
import * as React from 'react';
import { ReactNode, Suspense, useEffect, useRef } from 'react';

import Link from 'next/link';
import { usePathname } from 'next/navigation';

import { AccountChecker } from '../account/account-ui';
import {
  ClusterChecker,
  ClusterUiSelect,
  ExplorerLink,
} from '../cluster/cluster-ui';
import toast, { Toaster } from 'react-hot-toast';

export function UiLayout({
  children,
  links,
}: {
  children: ReactNode;
  links: { label: string; path: string }[];
}) {
  const pathname = usePathname();

  return (
    <div className="h-full flex flex-col">
      <div className="navbar bg-base-300 text-neutral-content flex-col md:flex-row space-y-2 md:space-y-0">
        <div className="flex-1">
          <Link className="btn btn-ghost normal-case text-xl" href="/">
            <img className="h-4 md:h-6" alt="Logo" src="/logo.png" />
          </Link>
          <ul className="menu menu-horizontal px-1 space-x-2">
            {links.map(({ label, path }) => (
              <li key={path}>
                <Link
                  className={pathname.startsWith(path) ? 'active' : ''}
                  href={path}
                >
                  {label}
                </Link>
              </li>
            ))}
          </ul>
        </div>
        <div className="flex-none space-x-2">
          <WalletButton />
          <ClusterUiSelect />
        </div>
      </div>
      <ClusterChecker>
        <AccountChecker />
      </ClusterChecker>
      <div className="flex-grow w-full mx-4 lg:w-3/4 lg:mx-auto">
        <Suspense
          fallback={
            <div className="text-center my-32">
              <span className="loading loading-spinner loading-lg"></span>
            </div>
          }
        >
          {children}
        </Suspense>
        <Toaster position="bottom-right" />
      </div>
      <footer className="footer footer-center p-4 bg-base-300 text-base-content">
        <aside>
          <p>
            Generated by{' '}
            <a
              className="link hover:text-white"
              href=""
              target="_blank"
              rel="noopener noreferrer"
            >
              Gigentic
            </a>
          </p>
        </aside>
      </footer>
    </div>
  );
}

export function AppModal({
  children,
  title,
  hide,
  show,
  submit,
  submitDisabled,
  submitLabel,
}: {
  children: ReactNode;
  title: string;
  hide: () => void;
  show: boolean;
  submit?: () => void;
  submitDisabled?: boolean;
  submitLabel?: string;
}) {
  const dialogRef = useRef<HTMLDialogElement | null>(null);

  useEffect(() => {
    if (!dialogRef.current) return;
    if (show) {
      dialogRef.current.showModal();
    } else {
      dialogRef.current.close();
    }
  }, [show, dialogRef]);

  return (
    <dialog className="modal" ref={dialogRef}>
      <div className="modal-box space-y-5">
        <h3 className="font-bold text-lg">{title}</h3>
        {children}
        <div className="modal-action">
          <div className="join space-x-2">
            {submit ? (
              <button
                className="btn btn-xs lg:btn-md btn-primary"
                onClick={submit}
                disabled={submitDisabled}
              >
                {submitLabel || 'Save'}
              </button>
            ) : null}
            <button onClick={hide} className="btn">
              Close
            </button>
          </div>
        </div>
      </div>
    </dialog>
  );
}

export function AppHero({
  children,
  title,
  subtitle,
}: {
  children?: ReactNode;
  title: ReactNode;
  subtitle: ReactNode;
}) {
  return (
    <div className="hero py-[64px]">
      <div className="hero-content text-center">
        <div className="max-w-2xl">
          {typeof title === 'string' ? (
            <h1 className="text-5xl font-bold">{title}</h1>
          ) : (
            title
          )}
          {typeof subtitle === 'string' ? (
            <p className="py-6">{subtitle}</p>
          ) : (
            subtitle
          )}
          {children}
        </div>
      </div>
    </div>
  );
}

export function ellipsify(str = '', len = 4) {
  if (str.length > 30) {
    return (
      str.substring(0, len) + '..' + str.substring(str.length - len, str.length)
    );
  }
  return str;
}

export function useTransactionToast() {
  return (signature: string) => {
    toast.success(
      <div className={'text-center'}>
        <div className="text-lg">Transaction sent</div>
        <ExplorerLink
          path={`tx/${signature}`}
          label={'View Transaction'}
          className="btn btn-xs btn-primary"
        />
      </div>,
    );
  };
}


// File: web/index.d.ts
/* eslint-disable @typescript-eslint/no-explicit-any */
declare module '*.svg' {
  const content: any;
  export const ReactComponent: any;
  export default content;
}


// File: web/next-env.d.ts
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/basic-features/typescript for more information.


// File: web/next.config.js
//@ts-check

// eslint-disable-next-line @typescript-eslint/no-var-requires
const { composePlugins, withNx } = require('@nx/next');

/**
 * @type {import('@nx/next/plugins/with-nx').WithNxOptions}
 **/
const nextConfig = {
  webpack: (config) => {
    config.externals = [
      ...(config.externals || []),
      'bigint',
      'node-gyp-build',
    ];
    return config;
  },
  nx: {
    // Set this to true if you would like to use SVGR
    // See: https://github.com/gregberge/svgr
    svgr: false,
  },
};

const plugins = [
  // Add more Next.js plugins to this list if needed.
  withNx,
];

module.exports = composePlugins(...plugins)(nextConfig);


// File: web/postcss.config.js
const { join } = require('path');

// Note: If you use library-specific PostCSS/Tailwind configuration then you should remove the `postcssConfig` build
// option from your application's configuration (i.e. project.json).
//
// See: https://nx.dev/guides/using-tailwind-css-in-react#step-4:-applying-configuration-to-libraries

module.exports = {
  plugins: {
    tailwindcss: {
      config: join(__dirname, 'tailwind.config.js'),
    },
    autoprefixer: {},
  },
};


// File: web/project.json
{
  "name": "web",
  "$schema": "../node_modules/nx/schemas/project-schema.json",
  "sourceRoot": "web",
  "projectType": "application",
  "tags": [],
  "targets": {
    "build": {
      "executor": "@nx/next:build",
      "outputs": ["{options.outputPath}"],
      "defaultConfiguration": "production",
      "options": {
        "outputPath": "dist/web"
      },
      "configurations": {
        "development": {
          "outputPath": "web"
        },
        "production": {}
      }
    },
    "serve": {
      "executor": "@nx/next:server",
      "defaultConfiguration": "development",
      "options": {
        "buildTarget": "web:build",
        "dev": true,
        "port": 3000
      },
      "configurations": {
        "development": {
          "buildTarget": "web:build:development",
          "dev": true
        },
        "production": {
          "buildTarget": "web:build:production",
          "dev": false
        }
      }
    },
    "export": {
      "executor": "@nx/next:export",
      "options": {
        "buildTarget": "web:build:production"
      }
    },
    "lint": {
      "executor": "@nx/eslint:lint"
    }
  }
}


// File: web/public/.gitkeep


// File: web/tailwind.config.js
const { createGlobPatternsForDependencies } = require('@nx/react/tailwind');
const { join } = require('path');

/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    join(
      __dirname,
      '{src,pages,components,app}/**/*!(*.stories|*.spec).{ts,tsx,html}'
    ),
    ...createGlobPatternsForDependencies(__dirname),
  ],
  theme: {
    extend: {},
  },
  plugins: [require('daisyui')],
};


// File: web/tsconfig.json
{
  "extends": "../tsconfig.base.json",
  "compilerOptions": {
    "jsx": "preserve",
    "allowJs": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ]
  },
  "include": [
    "**/*.ts",
    "**/*.tsx",
    "**/*.js",
    "**/*.jsx",
    "../web/.next/types/**/*.ts",
    "../dist/web/.next/types/**/*.ts",
    "next-env.d.ts",
    ".next/types/**/*.ts"
  ],
  "exclude": ["node_modules", "jest.config.ts", "**/*.spec.ts", "**/*.test.ts"]
}


